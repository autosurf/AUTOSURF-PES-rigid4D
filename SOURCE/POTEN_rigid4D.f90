!*******************************  A U T O S U R F  *********************************
!===================================================================================
!-----------------------------------------------------------------------------------
!-                                                                                 -
!-        AUTOSURF Package: A set of programs for the automated construction       -
!-              of Potential Energy Surfaces on van der Waals systems              -
!-                                                                                 -
!-----------------------------------------------------------------------------------
!===================================================================================
!***********************************************************************************
!-----------------------------------------------------------------------------------
!-        Input files: "input-AUTOSURF-PES.dat" & "PES-file"                       -
!-                                                                                 -
!***********************************************************************************
!!                                                                                !!
!! Fitted range: rmin(1) < R < rmax(1), as specified in the input file.           !!
!! Jac3(1) is R, the distance between centers of mass (in Angstroms).             !!
!! Jac3(2) and Jac3(3) are cos(theta1) and cos(theta2) and range from (-1,1).     !!
!! Jac3(4) is the dihedral angle, in radians, with range: (0,2pi).                !!
!! NAME1 is the name of the PES-file generated by AUTOSURF-PES.                   !!
!! Subroutine PES(jac3,V,NAME1) returns the potential "V".                        !!
!! Output energy is in kcal/mol.                                                  !!
!!                                                                                !!
!***********************************************************************************
SUBROUTINE PES(jac3,V,NAME1)  

use dynamic_parameters
!-----------------------------------------------------------------------------------
implicit none
 integer,parameter :: XDIM=4
 character (len=40) :: NAME1 
 character (len=300) :: line
 integer :: i,initflag,nline,ncont1
 real*8 :: xi(XDIM),jac3(XDIM)
 real*8 :: temp3,v,pii
 real*8,allocatable :: cart3(:)
 logical :: logica1
 save initflag
 data initflag /1/

INTERFACE! 
  FUNCTION func_actual(xi)    
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
      REAL(SP), DIMENSION(:), INTENT(IN) :: xi
      REAL(SP) :: func_actual
  END FUNCTION func_actual
end interface
INTERFACE! 
  FUNCTION func_actual_seed(xi)  
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
      REAL(SP), DIMENSION(:), INTENT(IN) :: xi
      REAL(SP) :: func_actual_seed
  END FUNCTION func_actual_seed
END INTERFACE
!-----------------------------------------------------------------------------------

pii=dacos(-1d0)
nline=scan(NAME1,' ')-1

! check if PES file exists...
inquire(file=NAME1(1:nline),exist=logica1)
if(.not.logica1)then
 write(*,*)
 write(*,*)'ERROR: The file: ',NAME1(1:nline),' does not exist !! '
 stop 
endif
! check if input file exist...
inquire(file='input-AUTOSURF-PES.dat',exist=logica1)
if(.not.logica1)then
 write(*,*)
 write(*,*)'ERROR: The file: input-AUTOSURF-PES.dat does not exist !! '
 stop 
endif

!***********************************************************************************
!                            INITIALIZATION
!***********************************************************************************
IF(initflag==1)THEN! initialize   

  ddd=4
  alpha=-1.0d0!
  xbeta=1.0
  epss=1d-14
  zz=4
  zz_low=6
  zz4=20
  dist_tol=1.25d0
  order_1_min=3  
  order_2_min=3
  order_3_min=3
  order_4_min=3

  allocate(jac(XDIM),jac2(XDIM))
  open(unit=10,file='input-AUTOSURF-PES.dat',status='old',action='read')
  112 read(10,'(A100)')line
  ncont1=INDEX(line,'FRAGMENTS INFORMATION:')
  if (ncont1==0) goto 112
  read(10,*)
  read(10,*)exch
  read(10,*)flip1
  read(10,*)flip2
  symparts=((exch+1)*(flip1+1)*(flip2+1))
  read(10,*) natom1! number of atoms in frag1
  read(10,*) natom2! number of atoms in frag2
  natom=natom1+natom2
  nbdist=natom*(natom-1)/2
  W_a=0.432d0*3/max(natom1,natom2)! scaling for R in dist metric, suggested: 1/fraglength
  allocate(ref1(3*natom1),ref2(3*natom2),bdist(nbdist),cart(3*(natom)))
  allocate(symb(natom),mass(natom))
  do i=1,natom
    read(10,*) symb(i)! element labels of all atoms
  enddo
  do i=1,natom
    read(10,*) mass(i)! masses of all atoms
  enddo  
  do i=1,3*natom1
    read(10,*) ref1(i)! Cartesian positions for fragment 1 atoms
  enddo
  do i=1,3*natom2
    read(10,*) ref2(i)! Cartesian positions for fragment 2 atoms
  enddo
  close(10)
  !# PES INFORMATION:
  OPEN (UNIT=652, FILE=NAME1(1:nline), FORM='UNFORMATTED', ACCESS='SEQUENTIAL') 
  read(652) count3
  read(652) order_1
  read(652) order_2
  read(652) order_3
  read(652) order_4
  read(652) maxpoints
  read(652) mass
  read(652) rmax
  read(652) rmin
  read(652) Max_E
  read(652) low_grid
  read(652) count_seed
  call basis_size(XDIM,order_1,order_2,order_3,order_4,basis_1)
  call basis_size(XDIM,order_1-1,order_2-1,order_3-1,order_4-1,basis_2)  
  call basis_size(XDIM,order_1_min,order_2_min,order_3_min,order_4_min,basis_3) 
  allocate(b2(basis_1,count3),b2_lower(basis_2,count3),b2_minimal(basis_3,count3),d(count3),coords(count3,XDIM)) 
  allocate(b2_seed(basis_3,count_seed),d_seed(count_seed),coords_seed(count_seed,XDIM))
  b2=0d0
  b2_lower=0d0
  b2_minimal=0d0
  b2_seed=0d0
  d=0d0
  d_seed=0d0
  coords=0d0
  coords_seed=0d0
  do i=1,count3 
     read(652) b2(:,i)       
  enddo
  do i=1,count3      
     read(652) b2_lower(:,i)       
  enddo
  do i=1,count3      
     read(652) b2_minimal(:,i)       
  enddo  
  do i=1,count3       
     read(652) d(i) 
  enddo
  do i=1,count3        
     read(652) coords(i,:)
  enddo
  if(low_grid>0)then
     read(652) Max_E_seed
     do i=1,count_seed      
        read(652) b2_seed(:,i)       
     enddo
     do i=1,count_seed 
        read(652) d_seed(i)       
     enddo
     do i=1,count_seed        
        read(652) coords_seed(i,:)       
     enddo
  endif
  close(652)
  initflag=2

  xi(1)=rmax(1)
  xi(2)=1.d0  
  xi(3)=1.d0  
  xi(4)=0.d0  
  ass=func_actual(xi)

ENDIF
!***********************************************************************************

allocate(cart3(3*(natom)))
xi=jac3

if(xi(1)<rmin(1))then
  v=Max_E
  !write(*,*) 'coords outside fitted range'
  !write(*,*)  xi(1),rmax(1),rmin(1)
  return
endif
if(xi(4)>pii)then
  xi(4)=xi(4)-2d0*pii
endif
if(xi(4)<-pii)then
  xi(4)=xi(4)+2d0*pii
endif
if(xi(2)>1d0)then
  xi(2)=2d0-xi(2)
endif
if(xi(3)>1d0)then
  xi(3)=2d0-xi(3)
endif
if(xi(2)<-1d0)then
  xi(2)=-2d0-xi(2)
endif
if(xi(3)<-1d0)then
  xi(3)=-2d0-xi(3)
endif

call INT_Cart(cart3,xi,mass,natom1,natom2,ref1,ref2)
!write(*,*)
!write(*,*)xi
!write(*,*)
!write(*,*)cart3
!write(*,*)
call cart_to_bdist_inter(cart3,natom1,natom2,dist_tol,dist_flag)
if(dist_flag==1) then
  v=Max_E-ass
  !write(*,*) 'bdist less than distol'
  return
endif

if(low_grid>0)then
  temp3=func_actual_seed(xi)
  if(temp3>Max_E_seed)then
    v=Max_E-ass
    !write(*,*)xi(1),'hit ceiling on low grid'
    return
  endif
endif

temp3=func_actual(xi)
if(temp3>Max_E)then
  temp3=Max_E
  !write(*,*)xi(1),'hit ceiling (func_actual)'
endif

V=temp3-ass
return

END SUBROUTINE PES


!***********************************************************************************

!                    S U B R O U T I N E S   &   F U N C T I O N S                           

!***********************************************************************************

subroutine cart_to_bdist_inter(x,natom1,natom2,dist_tol,flag)
  implicit none
  integer :: i,j,k,flag,natom1,natom2
  real*8 :: x(3*(natom1+natom2)),summ,dist_tol
  flag=0
  do i=1,natom1
     do j=natom1+1,natom1+natom2
        summ=0d0
        do k=1,3
           summ=summ+(x(3*(i-1)+k)-x(3*(j-1)+k))**2
        enddo
        if(sqrt(summ)<dist_tol)then
           flag=1
        endif
     enddo
  enddo
  return
end subroutine cart_to_bdist_inter

subroutine basis_size(d,order_1,order_2,order_3,order_4,basis)
  
 implicit none
 integer :: d,order_1,order_2,order_3,order_4,count,basis,l1,l2,m
   
 count=0
 do l1=0,order_2
   do l2=0,order_3
     if((l1+l2)<order_4+1)then
       do m=0,min(l1,l2)
        count=count+1
       enddo
     endif
   enddo
 enddo
 basis=count*(order_1)+1

return
end subroutine basis_size

subroutine INT_Cart(cart,internal2,mass,natom1,natom2,ref1,ref2)

 implicit none
 integer :: i,k,kp,natom1,natom2
 real*8 :: internal(6),internal2(4),cart((natom1+natom2)*3),mass(natom1+natom2),   &
            ref1(natom1*3),ref1_temp(natom1*3),ref2(natom2*3),ref2_temp(natom2*3)
 real*8 :: cart_ref1(3,natom1),cm(3),cart_ref2(3,natom2),cart_ref1t(3,natom1),     &
            cart_ref2t(3,natom2),U_rot(3,3)
 real*8 :: pii,gamma1,gamma2,beta1,beta2,alpha1,alpha2
 
 pii=acos(-1d0)
 internal(1)=internal2(1)
 internal(2)=0d0
 internal(3)=internal2(2)
 internal(4)=0d0
 internal(5)=internal2(3)
 internal(6)=internal2(4)
 ref1_temp=ref1
 ref2_temp=ref2
 call rm_cmass(ref1_temp,mass(1:natom1),natom1,natom1)
 call rm_cmass(ref2_temp,mass(natom1+1:natom1+natom2),natom2,natom2)
 cm(1)=0d0
 cm(2)=0d0
 cm(3)=internal(1)
 alpha1=0d0
 gamma1=internal(2)
 beta1=acos(internal(3))
 U_rot(1,1)=cos(alpha1)*cos(beta1)*cos(gamma1)-sin(alpha1)*sin(gamma1)
 U_rot(1,2)=-cos(alpha1)*cos(beta1)*sin(gamma1)-sin(alpha1)*cos(gamma1)
 U_rot(1,3)=cos(alpha1)*sin(beta1)
 U_rot(2,1)=sin(alpha1)*cos(beta1)*cos(gamma1)+cos(alpha1)*sin(gamma1)
 U_rot(2,2)=-sin(alpha1)*cos(beta1)*sin(gamma1)+cos(alpha1)*cos(gamma1)
 U_rot(2,3)=sin(alpha1)*sin(beta1)
 U_rot(3,1)=-sin(beta1)*cos(gamma1)
 U_rot(3,2)=sin(beta1)*sin(gamma1)
 U_rot(3,3)=cos(beta1)
 call vec_to_mat2(ref1_temp,cart_ref1,natom1)
 call rotmol(natom1,cart_ref1,cart_ref1t,U_rot)
 call mat_to_vec2(cart_ref1t,ref1_temp,natom1)
 gamma2=internal(4)
 beta2=acos(internal(5))
 alpha2=-internal(6)
 U_rot(1,1)=cos(alpha2)*cos(beta2)*cos(gamma2)-sin(alpha2)*sin(gamma2)
 U_rot(1,2)=-cos(alpha2)*cos(beta2)*sin(gamma2)-sin(alpha2)*cos(gamma2)
 U_rot(1,3)=cos(alpha2)*sin(beta2)
 U_rot(2,1)=sin(alpha2)*cos(beta2)*cos(gamma2)+cos(alpha2)*sin(gamma2)
 U_rot(2,2)=-sin(alpha2)*cos(beta2)*sin(gamma2)+cos(alpha2)*cos(gamma2)
 U_rot(2,3)=sin(alpha2)*sin(beta2)
 U_rot(3,1)=-sin(beta2)*cos(gamma2)
 U_rot(3,2)=sin(beta2)*sin(gamma2)
 U_rot(3,3)=cos(beta2)
 call vec_to_mat2(ref2_temp,cart_ref2,natom2)
 call rotmol(natom2,cart_ref2,cart_ref2t,U_rot)
 call mat_to_vec2(cart_ref2t,ref2_temp,natom2)
 do k=1,natom2
   do kp=1,3
    ref2_temp((k-1)*3+kp)=ref2_temp((k-1)*3+kp)+cm(kp)      
   enddo
 enddo
 do i=1,3*natom2
   cart(3*natom1+i)=ref2_temp(i)
 enddo
 do i=1,3*natom1
   cart(i)=ref1_temp(i)
 enddo

return
end subroutine INT_Cart

subroutine rm_cmass(cart,mass,natom,natom1)
integer :: k,kp,natom,natom1
real*8 :: mass(natom),cart(natom*3),mtot,cmass1(3)
mtot=0d0
do k=1,natom1
   mtot=mtot+mass(k)
enddo
cmass1=0d0
do k=1,natom1
   do kp=1,3
      cmass1(kp)=cmass1(kp)+cart((k-1)*3+kp)*mass(k)
   enddo
enddo
cmass1=cmass1/mtot
do k=1,natom
   do kp=1,3
      cart((k-1)*3+kp)=cart((k-1)*3+kp)-cmass1(kp)      
   enddo
enddo
return
end subroutine rm_cmass

subroutine vec_to_mat2(cart_perms,cart_mat,natom)
integer :: k,kp,natom
real*8 :: cart_perms(3*natom),cart_mat(3,natom)
do k=1,natom
   do kp=1,3
      cart_mat(kp,k)=cart_perms((k-1)*3+kp)
   enddo
enddo
return
end subroutine vec_to_mat2

subroutine mat_to_vec2(cart_mat,cart_perms,natom)
integer :: k,kp,natom
real*8 :: cart_perms(3*natom),cart_mat(3,natom)
do k=1,natom
   do kp=1,3
      cart_perms((k-1)*3+kp)=cart_mat(kp,k)
   enddo
enddo
return
end subroutine mat_to_vec2

subroutine dist_metric(jac,jac2,scale,dist)
integer :: i
real*8 :: jac(4),jac2(4),scale,dist,temp(4),pii
pii=acos(-1d0)
temp(1)=((jac(1)-jac2(1))*scale)**2
temp(2)=(acos(jac(2))-acos(jac2(2)))**2
temp(3)=(acos(jac(3))-acos(jac2(3)))**2
temp(4)=jac(4)-jac2(4)
if(temp(4)>pii)then
   temp(4)=temp(4)-2d0*pii
endif
if(temp(4)<-pii)then
   temp(4)=temp(4)+2d0*pii
endif
temp(4)=(temp(4)**2)*sqrt((1d0-jac(2)**2)*(1d0-jac2(2)**2)*(1d0-jac(3)**2)*(1d0-jac2(3)**2))
dist=0d0
do i=1,4
   dist=dist+temp(i)
enddo
dist=sqrt(dist)
return
end subroutine dist_metric

SUBROUTINE indexxy(n,arr,indx)
  INTEGER :: n
  integer,parameter :: nstack=50, m=7
  INTEGER ::indx(n),istack(nstack)
  REAL*8 :: arr(n)
  INTEGER :: i,indxt,ir,itemp,j,jstack,k,l
  REAL*8 :: a
 
  do j=1,n
     indx(j)=j
  enddo
  jstack=0
  l=1
  ir=n
1 if(ir-l.lt.M)then
     do j=l+1,ir
        indxt=indx(j)
        a=arr(indxt)
        do i=j-1,1,-1
           if(arr(indx(i)).le.a)goto 2
           indx(i+1)=indx(i)
        enddo
        i=0
2       indx(i+1)=indxt
     enddo
     if(jstack.eq.0)return
     ir=istack(jstack)
     l=istack(jstack-1)
     jstack=jstack-2
  else
     k=(l+ir)/2
     itemp=indx(k)
     indx(k)=indx(l+1)
     indx(l+1)=itemp
     if(arr(indx(l+1)).gt.arr(indx(ir)))then
        itemp=indx(l+1)
        indx(l+1)=indx(ir)
        indx(ir)=itemp
     endif
     if(arr(indx(l)).gt.arr(indx(ir)))then
        itemp=indx(l)
        indx(l)=indx(ir)
        indx(ir)=itemp
     endif
     if(arr(indx(l+1)).gt.arr(indx(l)))then
        itemp=indx(l+1)
        indx(l+1)=indx(l)
        indx(l)=itemp
     endif
     i=l+1
     j=ir
     indxt=indx(l)
     a=arr(indxt)
3    continue
     i=i+1
     if(arr(indx(i)).lt.a)goto 3
4    continue
     j=j-1
     if(arr(indx(j)).gt.a)goto 4
     if(j.lt.i)goto 5
     itemp=indx(i)
     indx(i)=indx(j)
     indx(j)=itemp
     goto 3
5    indx(l)=indx(j)
     indx(j)=indxt
     jstack=jstack+2
!     if(jstack.gt.NSTACK)pause 'NSTACK too small in indexx'
     if(jstack.gt.NSTACK)write(6,*)'NSTACK too small in indexx'
     if(ir-i+1.ge.j-l)then
        istack(jstack)=ir
        istack(jstack-1)=i
        ir=j-1
     else
        istack(jstack)=j-1
        istack(jstack-1)=l
        l=i
     endif
  endif
  goto 1
  return

end subroutine indexxy

FUNCTION dbrent(ax,bx,cx,func,dfunc,tol,xmin)

USE nrtype; USE nrutil, ONLY : nrerror
IMPLICIT NONE
REAL(SP), INTENT(IN) :: ax,bx,cx,tol
REAL(SP), INTENT(OUT) :: xmin
REAL(SP) :: dbrent
INTERFACE
  FUNCTION func(x)
  USE nrtype
    IMPLICIT NONE
    REAL(SP), INTENT(IN) :: x
    REAL(SP) :: func
  END FUNCTION func
  FUNCTION dfunc(x)
  USE nrtype
    IMPLICIT NONE
    REAL(SP), INTENT(IN) :: x
    REAL(SP) :: dfunc
  END FUNCTION dfunc
END INTERFACE

INTEGER(I4B), PARAMETER :: ITMAX=100
REAL(SP), PARAMETER :: ZEPS=1.0e-3_sp*epsilon(ax)
INTEGER(I4B) :: iter
REAL(SP) :: a,b,d,d1,d2,du,dv,dw,dx,e,fu,fv,fw,fx,olde,tol1,tol2,&
	u,u1,u2,v,w,x,xm
LOGICAL :: ok1,ok2
a=min(ax,cx)
b=max(ax,cx)
v=bx
w=v
x=v
e=0.0
fx=func(x)
fv=fx
fw=fx
dx=dfunc(x)
dv=dx
dw=dx
do iter=1,ITMAX
	xm=0.5_sp*(a+b)
	tol1=tol*dabs(x)+ZEPS
	tol2=2.0_sp*tol1
	if (dabs(x-xm) <= (tol2-0.5_sp*(b-a))) exit
	if (dabs(e) > tol1) then
		d1=2.0_sp*(b-a)
		d2=d1
		if (dw /= dx) d1=(w-x)*dx/(dx-dw)
		if (dv /= dx) d2=(v-x)*dx/(dx-dv)
		u1=x+d1
		u2=x+d2
		ok1=((a-u1)*(u1-b) > 0.0) .and. (dx*d1 <= 0.0)
		ok2=((a-u2)*(u2-b) > 0.0) .and. (dx*d2 <= 0.0)
		olde=e
		e=d
		if (ok1 .or. ok2) then
			if (ok1 .and. ok2) then
				d=merge(d1,d2, dabs(d1) < dabs(d2))
			else
				d=merge(d1,d2,ok1)
			end if
			if (dabs(d) <= dabs(0.5_sp*olde)) then
				u=x+d
				if (u-a < tol2 .or. b-u < tol2) &
					d=dsign(tol1,xm-x)
			else
				e=merge(a,b, dx >= 0.0)-x
				d=0.5_sp*e
			end if
		else
			e=merge(a,b, dx >= 0.0)-x
			d=0.5_sp*e
		end if
	else
		e=merge(a,b, dx >= 0.0)-x
		d=0.5_sp*e
	end if
	if (dabs(d) >= tol1) then
		u=x+d
		fu=func(u)
	else
		u=x+sign(tol1,d)
		fu=func(u)
		if (fu > fx) exit
	end if
	du=dfunc(u)
	if (fu <= fx) then
		if (u >= x) then
			a=x
		else
			b=x
		end if
		call mov3(v,fv,dv,w,fw,dw)
		call mov3(w,fw,dw,x,fx,dx)
		call mov3(x,fx,dx,u,fu,du)
	else
		if (u < x) then
			a=u
		else
			b=u
		end if
		if (fu <= fw .or. w == x) then
			call mov3(v,fv,dv,w,fw,dw)
			call mov3(w,fw,dw,u,fu,du)
		else if (fu <= fv .or. v == x .or. v == w) then
			call mov3(v,fv,dv,u,fu,du)
		end if
	end if
end do
if (iter > ITMAX) call nrerror('dbrent: exceeded maximum iterations')
xmin=x
dbrent=fx
CONTAINS
SUBROUTINE mov3(a,b,c,d,e,f)
REAL(SP), INTENT(IN) :: d,e,f
REAL(SP), INTENT(OUT) :: a,b,c
 a=d
 b=e
 c=f
END SUBROUTINE mov3
END FUNCTION dbrent

function func_actual(xi)

use nrtype
USE dynamic_parameters
implicit none

integer,parameter :: XDIM=4
REAL(SP), DIMENSION(:), INTENT(IN) :: xi
REAL(SP) :: func_actual
integer :: i,ip,quitt,l1,l2,jj,R,M,count
real*8 :: temp,weight,norm,somme,jac3(XDIM),jac4(XDIM),pii
real*8,allocatable :: ind7(:),PM1(:,:),PM2(:,:),PD1(:,:),PD2(:,:)
integer,allocatable :: ind8(:)

pii=dacos(-1d0)
jac3=xi
allocate(ind7(count3),ind8(count3),PM1(0:order_2+1,0:order_2+1),PM2(0:order_3+1,0:order_3+1))
allocate(PD1(0:order_2+1,0:order_2+1),PD2(0:order_3+1,0:order_3+1))

count=0
do ip=1,count3 
  count=count+1
  Jac4=coords(ip,:)
  call dist_metric(jac3,jac4,W_a,somme)
  somme=somme**2
  ind7(count)=dexp(-((somme)/d(ip)**2))/(((somme)/d(ip)**2)**(zz/2)+epss)
enddo
call indexxy(count3,ind7,ind8)
quitt=0! 
do ip=1,count3
  if(ind7(ind8(count3))/ind7(ind8(count3+1-ip))>1d11) goto 12
  quitt=quitt+1
enddo
12 jac3=xi
Jac4=jac3
jac4(1)=dexp(alpha*jac4(1)**xbeta)
call LPMN(order_2+1,order_2,order_2,jac4(2),PM1,PD1)
call LPMN(order_3+1,order_3,order_3,jac4(3),PM2,PD2)
norm=0d0
temp=0d0
do i=1,quitt
  jj=ind8(count3+1-i)
!  if(pot(jj)<E_limit)then
   weight=ind7(ind8(count3+1-i)) 
   !write(665,*) weight
   norm=norm+weight
   temp=temp+weight*b2(1,jj)
   count=1
   do R=1,order_1
     do L1=0,order_2
       do L2=0,order_3
         if((L1+L2)<order_4+1)then
           do M=0,min(L1,L2)
            count=count+1
            temp=temp+weight*b2(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)*dcos(dble(M)*jac4(4))
           enddo
         endif
       enddo
     enddo
   enddo
!  endif
enddo
func_actual=temp/norm

return
end function func_actual

function func_actual_seed(xi)

use nrtype
USE dynamic_parameters
implicit none

integer,parameter :: XDIM=4
REAL(SP), DIMENSION(:), INTENT(IN) :: xi
REAL(SP) :: func_actual_seed
integer :: i,ip,quitt,l1,l2,jj,R,M
integer :: count
real*8 :: temp,weight,norm,somme,jac3(XDIM),jac4(XDIM),pii
real*8,allocatable :: ind7(:),PM1(:,:),PM2(:,:),PD1(:,:),PD2(:,:)
integer,allocatable :: ind8(:)

pii=dacos(-1d0)
jac3=xi
allocate(ind7(count_seed),ind8(count_seed),PM1(0:order_2_min+1,0:order_2_min+1))
allocate(PM2(0:order_3_min+1,0:order_3_min+1),PD1(0:order_2_min+1,0:order_2_min+1))
allocate(PD2(0:order_3_min+1,0:order_3_min+1))
count=0
do ip=1,count_seed 
  count=count+1
  Jac4=coords_seed(ip,:)
  call dist_metric(jac3,jac4,W_a,somme)
  somme=somme**2
  ind7(count)=dexp(-((somme)/d_seed(ip)**2))/(((somme)/d_seed(ip)**2)**(zz_low/2)+epss)
enddo
call indexxy(count_seed,ind7,ind8)
quitt=0! 
do ip=1,count_seed
   if(ind7(ind8(count_seed))/ind7(ind8(count_seed+1-ip))>1d11) goto 12
   quitt=quitt+1
enddo
12 jac3=xi
Jac4=jac3
jac4(1)=dexp(alpha*jac4(1)**xbeta)
call LPMN(order_2_min+1,order_2_min,order_2_min,jac4(2),PM1,PD1)
call LPMN(order_3_min+1,order_3_min,order_3_min,jac4(3),PM2,PD2)
norm=0d0
temp=0d0
do i=1,quitt
  jj=ind8(count_seed+1-i)
!  if(pot(jj)<E_limit)then
   weight=ind7(ind8(count_seed+1-i)) 
   ! write(665,*) weight
   norm=norm+weight
   temp=temp+weight*b2_seed(1,jj)
   count=1
   do R=1,order_1_min
     do L1=0,order_2_min
       do L2=0,order_3_min
         if((L1+L2)<order_4_min+1)then
           do M=0,min(L1,L2)
             count=count+1
             temp=temp+weight*b2_seed(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)* &
                  dcos(dble(M)*jac4(4))
           enddo
         endif
       enddo
     enddo
   enddo
!  endif
enddo
func_actual_seed=temp/norm

return
end function func_actual_seed

function func(xi)

use nrtype
USE dynamic_parameters
implicit none

INTERFACE
  FUNCTION func_actual_min(xi)
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
    REAL(SP), DIMENSION(:), INTENT(IN) :: xi
    REAL(SP) :: func_actual_min
  END FUNCTION func_actual_min
end interface
INTERFACE
  FUNCTION func_actual_seed(xi)
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
    REAL(SP), DIMENSION(:), INTENT(IN) :: xi
    REAL(SP) :: func_actual_seed
  END FUNCTION func_actual_seed
end interface

REAL(SP), DIMENSION(:), INTENT(IN) :: xi
REAL(SP) :: func
integer :: i,j,k,ipp,jpp,ip,quitt,l1,l2,l3,l4,count2,l,jp,jj,kk,R,M
integer :: count
real*8 :: temp,weight,norm,somme,jac3(4),jac4(4),tampon,h2wn,dist,temp1,temp2,diff(4),pii
real*8,allocatable :: ind7(:),PM1(:,:),PM2(:,:),PD1(:,:),PD2(:,:)
integer,allocatable :: ind8(:)

pii=acos(-1d0)
do j=1,4
  if(xi(j)>rmax(j).or.xi(j)<rmin(j))then
    func=0d0
    return
  endif
enddo
call INT_Cart(cart,xi,mass,natom1,natom2,ref1,ref2)
call cart_to_bdist_inter(cart,natom1,natom2,dist_tol,dist_flag)
if(dist_flag==1) then
  func=0d0
  return
endif
if(low_grid>0) then
  temp=func_actual_seed(xi)
  if(temp>Max_E_seed)then
    func=0d0
    return
  endif
endif
temp1=func_actual_min(xi)
if(subzero==0)then
  if(temp1>Max_E)then
    func=0d0
    return
  endif
endif
if(subzero==1)then
  if(temp1+temp>Max_E)then
    func=0d0
    return
  endif
endif
allocate(ind7(count3),ind8(count3),PM1(0:order_2+1,0:order_2+1),PM2(0:order_3+1,0:order_3+1))
allocate(PD1(0:order_2+1,0:order_2+1),PD2(0:order_3+1,0:order_3+1))
jac3=xi
count=0
do ip=1,count3 
  count=count+1
  Jac4=coords(ip,:)
  call dist_metric(jac3,jac4,W_a,somme)
  somme=somme**2
  ind7(count)=exp(-((somme)/d(ip)**2))/(((somme)/d(ip)**2)**(zz/2)+epss)
enddo
call indexxy(count3,ind7,ind8)
quitt=0! 
do ip=1,count3
  if(ind7(ind8(count3))/ind7(ind8(count3+1-ip))>1d11) goto 12
  quitt=quitt+1
enddo
!write(701,*) quitt
12 norm=0d0
temp=0d0
jac3=xi
jac4=jac3
jac4(1)=exp(alpha*jac4(1)**xbeta)
call LPMN(order_2+1,order_2,order_2,jac4(2),PM1,PD1)
call LPMN(order_3+1,order_3,order_3,jac4(3),PM2,PD2)
do i=1,quitt
  jj=ind8(count3+1-i)
  weight=ind7(ind8(count3+1-i)) 
  norm=norm+weight
  temp=temp+weight*b2(1,jj)
  count=1
  do R=1,order_1
    do L1=0,order_2
      do L2=0,order_3
        if((L1+L2)<order_4+1)then
          do M=0,min(L1,L2)
           count=count+1
           temp=temp+weight*b2(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)*cos(dble(M)*jac4(4))
          enddo
        endif
      enddo
    enddo
  enddo
enddo
func=temp/norm
order_1=order_1-1
order_2=order_2-1
order_3=order_3-1
order_4=order_4-1
norm=0d0
temp=0d0
do i=1,quitt  
  jj=ind8(count3+1-i)   
  weight=ind7(ind8(count3+1-i)) 
  norm=norm+weight   
  temp=temp+weight*b2_lower(1,jj)
  count=1
  do R=1,order_1
    do L1=0,order_2
      do L2=0,order_3
        if((L1+L2)<order_4+1)then
          do M=0,min(L1,L2)
           count=count+1
           temp=temp+weight*b2_lower(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)*cos(dble(M)*jac4(4))
          enddo
        endif
      enddo
    enddo
  enddo
enddo
deallocate(ind7,ind8)
func=-abs(func-temp/norm)**2
!write(550+myid,*) xi
!write(550+myid,*) func
order_1=order_1+1
order_2=order_2+1
order_3=order_3+1
order_4=order_4+1

return
end function func

function func1(xi)

use nrtype
USE dynamic_parameters
implicit none

INTERFACE
  FUNCTION func_actual_min(xi)
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
    REAL(SP), DIMENSION(:), INTENT(IN) :: xi
    REAL(SP) :: func_actual_min
  END FUNCTION func_actual_min
end interface
INTERFACE
  FUNCTION func_actual_seed(xi)
    use nrtype
    USE dynamic_parameters
    IMPLICIT NONE
    REAL(SP), DIMENSION(:), INTENT(IN) :: xi
    REAL(SP) :: func_actual_seed
  END FUNCTION func_actual_seed
end interface

REAL(SP), DIMENSION(:), INTENT(IN) :: xi
REAL(SP) :: func1
integer :: i,j,k,ipp,jpp,ip,quitt,l1,l2,l3,l4,count2,l,jp,jj,kk,R,M
integer :: count
real*8 :: temp,weight,norm,somme,jac3(4),jac4(4),tampon,h2wn,dist,temp1,temp2,diff(4),pii
real*8,allocatable :: ind7(:),PM1(:,:),PM2(:,:),PD1(:,:),PD2(:,:)
integer,allocatable :: ind8(:)

pii=acos(-1d0)
 if(xi(1)>rmax(1).or.xi(1)<rmin(1))then
   func1=0d0
   return
 endif
do j=2,3
 if(xi(j)>1d0.or.xi(j)<-1d0)then
   func1=0d0
   return
 endif
enddo
 if(xi(4)>pii.or.xi(4)<(-1.d0*pii))then
   func1=0d0
   return
 endif
call INT_Cart(cart,xi,mass,natom1,natom2,ref1,ref2)
call cart_to_bdist_inter(cart,natom1,natom2,dist_tol,dist_flag)
if(dist_flag==1) then
  func1=0d0
  return
endif
if(low_grid>0) then
  temp=func_actual_seed(xi)
  if(temp>Max_E_seed)then
    func1=0d0
    return
  endif
endif
temp1=func_actual_min(xi)
if(subzero==0)then
  if(temp1>Max_E)then
    func1=0d0
    return
  endif
endif
if(subzero==1)then
  if(temp1+temp>Max_E)then
    func1=0d0
    return
  endif
endif
allocate(ind7(count3),ind8(count3),PM1(0:order_2+1,0:order_2+1),PM2(0:order_3+1,0:order_3+1))
allocate(PD1(0:order_2+1,0:order_2+1),PD2(0:order_3+1,0:order_3+1))
jac3=xi
count=0
do ip=1,count3 
  count=count+1
  Jac4=coords(ip,:)
  call dist_metric(jac3,jac4,W_a,somme)
  somme=somme**2
  ind7(count)=exp(-((somme)/d(ip)**2))/(((somme)/d(ip)**2)**(zz/2)+epss)
enddo
call indexxy(count3,ind7,ind8)
quitt=0!
do ip=1,count3
  if(ind7(ind8(count3))/ind7(ind8(count3+1-ip))>1d11) goto 12
  quitt=quitt+1
enddo
!write(701,*) quitt
12 norm=0d0
temp=0d0
jac3=xi
jac4=jac3
jac4(1)=exp(alpha*jac4(1)**xbeta)
call LPMN(order_2+1,order_2,order_2,jac4(2),PM1,PD1)
call LPMN(order_3+1,order_3,order_3,jac4(3),PM2,PD2)
do i=1,quitt
  jj=ind8(count3+1-i)
  weight=ind7(ind8(count3+1-i)) 
  norm=norm+weight
  temp=temp+weight*b2(1,jj)
  count=1
  do R=1,order_1
    do L1=0,order_2
      do L2=0,order_3
        if((L1+L2)<order_4+1)then
          do M=0,min(L1,L2)
           count=count+1
           temp=temp+weight*b2(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)*cos(dble(M)*jac4(4))
          enddo
        endif
      enddo
    enddo
  enddo
enddo
func1=temp/norm
order_1=order_1-1
order_2=order_2-1
order_3=order_3-1
order_4=order_4-1
norm=0d0
temp=0d0
do i=1,quitt  
  jj=ind8(count3+1-i)   
  weight=ind7(ind8(count3+1-i)) 
  norm=norm+weight   
  temp=temp+weight*b2_lower(1,jj)
  count=1
  do R=1,order_1
    do L1=0,order_2
      do L2=0,order_3
        if((L1+L2)<order_4+1)then
          do M=0,min(L1,L2)
           count=count+1
           temp=temp+weight*b2_lower(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)*cos(dble(M)*jac4(4))
          enddo
        endif
      enddo
    enddo
  enddo
enddo
deallocate(ind7,ind8)
func1=-abs(func1-temp/norm)**2
!write(550+myid,*) xi
!write(550+myid,*) func1
order_1=order_1+1
order_2=order_2+1
order_3=order_3+1
order_4=order_4+1

return
end function func1

function func_actual_min(xi)

use nrtype
USE dynamic_parameters
implicit none

REAL(SP), DIMENSION(:), INTENT(IN) :: xi
REAL(SP) :: func_actual_min
integer :: i,j,k,ipp,jpp,ip,quitt,l1,l2,l3,l4,count2,l,jp,jj,kk,R,M
integer :: count
real*8 :: temp,weight,norm,somme,jac3(4),jac4(4),temp1,temp2,diff(4),pii
real*8,allocatable :: ind7(:),PM1(:,:),PM2(:,:),PD1(:,:),PD2(:,:)
integer,allocatable :: ind8(:)

pii=acos(-1d0)
jac3=xi
allocate(ind7(count3),ind8(count3),PM1(0:order_2_min+1,0:order_2_min+1))
allocate(PM2(0:order_3_min+1,0:order_3_min+1),PD1(0:order_2_min+1,0:order_2_min+1))
allocate(PD2(0:order_3_min+1,0:order_3_min+1))
count=0
do ip=1,count3 
  count=count+1
  Jac4=coords(ip,:)
  call dist_metric(jac3,jac4,W_a,somme)
  somme=somme**2
  ind7(count)=exp(-((somme)/d(ip)**2))/(((somme)/d(ip)**2)**(zz/2)+epss)
enddo
call indexxy(count3,ind7,ind8)
quitt=0! 
do ip=1,count3
   if(ind7(ind8(count3))/ind7(ind8(count3+1-ip))>1d11) goto 12
   quitt=quitt+1
enddo
!write(701,*) quitt 
12 jac3=xi
Jac4=jac3
jac4(1)=exp(alpha*jac4(1)**xbeta)
call LPMN(order_2_min+1,order_2_min,order_2_min,jac4(2),PM1,PD1)
call LPMN(order_3_min+1,order_3_min,order_3_min,jac4(3),PM2,PD2)
norm=0d0
temp=0d0
do i=1,quitt
  jj=ind8(count3+1-i)
!  if(pot(jj)<E_limit)then
   weight=ind7(ind8(count3+1-i)) 
   ! write(665,*) weight
   norm=norm+weight
   temp=temp+weight*b2_minimal(1,jj)
   count=1
   do R=1,order_1_min
     do L1=0,order_2_min
       do L2=0,order_3_min
         if((L1+L2)<order_4_min+1)then
           do M=0,min(L1,L2)
             count=count+1
             temp=temp+weight*b2_minimal(count,jj)*(jac4(1))**(R)*PM1(M,L1)*PM2(M,L2)* &
                  cos(dble(M)*jac4(4))
           enddo
         endif
       enddo
     enddo
   enddo
!  endif
enddo
func_actual_min=temp/norm

return
end function func_actual_min
